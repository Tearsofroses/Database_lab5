    % ==========================================
    \section{Exercise 2 - Hotel Database Constraints}
    % ==========================================

    \textbf{Database Schema:}

    \textbf{Hotel}(\underline{hotelNo}, hotelName, city)\\
    \textbf{Room}(\underline{roomNo, hotelNo}, type, price, NumAdultMax) FK: hotelNo $\rightarrow$ Hotel\\
    \textbf{Booking}(\underline{hotelNo, dateFrom, roomNo}, guestNo, dateTo, NumOfAdult)\\
    \hspace*{1cm} FK: (roomNo, hotelNo) $\rightarrow$ Room, guestNo $\rightarrow$ Guest\\
    \textbf{Guest}(\underline{guestNo}, guestName, guestAddress, TotalAmount)

    \textbf{Constraints to implement:}
    \begin{enumerate}[label=\alph*.]
        \item The price of all double rooms must be greater than \$100.
        \item In a hotel, the price of double rooms must be greater than the price of the highest single room.
        \item A guest cannot make two bookings with overlapping dates.
        \item A guest cannot make a booking with number of adults greater than NumAdultMax value of booked room.
        \item Automatically calculate the value for totalAmount column of Guest relation.
        \item Create an INSTEAD OF database trigger that will allow data to be inserted into the LondonHotelRoom view.
    \end{enumerate}

    % --------------------
    \subsection{Constraint (a) - Double Room Price Minimum}
    % --------------------

    \textbf{Requirement:} The price of all double rooms must be greater than \$100.

    \textbf{Solution:} Using CHECK constraint (attribute constraint)

    \begin{lstlisting}
    ALTER TABLE Room 
    ADD CONSTRAINT chk_double_room_price 
    CHECK (type != 'double' OR price > 100);
    \end{lstlisting}

    \textbf{Explanation:} This CHECK constraint ensures that whenever a room has type 'double', its price must be greater than 100. The constraint is evaluated as (NOT double OR price $>$ 100), which is logically equivalent to (IF double THEN price $>$ 100).

    \subsubsection*{Test Validation}
    \begin{lstlisting}
    -- Display current state
    SELECT '=== Current Room Data ===' AS Info;
    SELECT * FROM Room;

    -- Test 1: Valid INSERT - Double room with price > 100
    SELECT '=== Test 1: Valid double room (price = 150) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (999, 1, 'double', 150, 2);
    SELECT * FROM Room WHERE roomNo = 999 AND hotelNo = 1;

    -- Test 2: Invalid INSERT - Double room with price < 100
    SELECT '=== Test 2: Invalid double room (price = 80) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (998, 1, 'double', 80, 2);
    -- Expected: Error - Check constraint violation

    -- Test 3: Invalid INSERT - Double room with price = 100
    SELECT '=== Test 3: Invalid double room (price = 100) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (997, 1, 'double', 100, 2);
    -- Expected: Error - Check constraint violation (must be GREATER than 100)

    -- Test 4: Valid INSERT - Single room with price < 100
    SELECT '=== Test 4: Valid single room (price = 50) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (996, 1, 'single', 50, 1);
    SELECT * FROM Room WHERE roomNo = 996 AND hotelNo = 1;

    -- Cleanup
    DELETE FROM Room WHERE roomNo IN (999, 996) AND hotelNo = 1;
    \end{lstlisting}

    \textbf{Expected Results:}
    \begin{center}
    \footnotesize
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Test} & \textbf{Action} & \textbf{Result} \\
    \hline
    Test 1 & INSERT double room price 150 & Success \\
    Test 2 & INSERT double room price 80 & Error - constraint violation \\
    Test 3 & INSERT double room price 100 & Error - must be $>$ 100 \\
    Test 4 & INSERT single room price 50 & Success \\
    \hline
    \end{tabular}
    \end{center}

    % --------------------
    \subsection{Constraint (b) - Double Room Pricing Hierarchy}
    % --------------------

    \textbf{Requirement:} In a hotel, the price of double rooms must be greater than the price of the highest single room.

    \textbf{Solution:} Using Triggers (requires querying existing data)

    \begin{lstlisting}
    DROP TRIGGER IF EXISTS trg_double_greater_single_insert;
    DELIMITER //
    CREATE TRIGGER trg_double_greater_single_insert
    BEFORE INSERT ON Room
    FOR EACH ROW
    BEGIN
        DECLARE max_single_price DECIMAL(10, 2);
        
        IF NEW.type = 'double' THEN
            SELECT IFNULL(MAX(price), 0) INTO max_single_price 
            FROM Room 
            WHERE hotelNo = NEW.hotelNo AND type = 'single';
            
            IF NEW.price <= max_single_price THEN
                SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Error: Double room price must be greater than highest single room price.';
            END IF;
        END IF;
    END //
    DELIMITER ;

    DROP TRIGGER IF EXISTS trg_double_greater_single_update;
    DELIMITER //
    CREATE TRIGGER trg_double_greater_single_update
    BEFORE UPDATE ON Room
    FOR EACH ROW
    BEGIN
        DECLARE max_single_price DECIMAL(10, 2);
        
        IF NEW.type = 'double' THEN
            SELECT IFNULL(MAX(price), 0) INTO max_single_price 
            FROM Room 
            WHERE hotelNo = NEW.hotelNo AND type = 'single' AND roomNo != NEW.roomNo;
            
            IF NEW.price <= max_single_price THEN
                SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Error: Double room price must be greater than highest single room price.';
            END IF;
        END IF;
    END //
    DELIMITER ;
    \end{lstlisting}

    \textbf{Explanation:} Triggers are necessary because this constraint requires comparing the new room price with existing prices in the database, which cannot be done with simple CHECK constraints.

    \subsubsection*{Test Validation}
    \begin{lstlisting}
    -- Display current state
    SELECT '=== Current Room Data for Hotel 1 ===' AS Info;
    SELECT * FROM Room WHERE hotelNo = 1 ORDER BY type, price;

    -- Test 1: Valid INSERT - Double room with price > highest single room
    SELECT '=== Test 1: Valid double room (price = 200, max single = 80) ===' AS Test;
    -- First, verify the highest single room price in hotel 1
    SELECT MAX(price) AS Max_Single_Price FROM Room WHERE hotelNo = 1 AND type = 'single';
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (999, 1, 'double', 200, 2);
    SELECT * FROM Room WHERE roomNo = 999 AND hotelNo = 1;

    -- Test 2: Invalid INSERT - Double room with price <= highest single room
    SELECT '=== Test 2: Invalid double room (price = 70, max single = 80) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (998, 1, 'double', 70, 2);
    -- Expected: Error - Double room price must be greater than highest single

    -- Test 3: Invalid INSERT - Double room with price = highest single room
    SELECT '=== Test 3: Invalid double room (price = 80, max single = 80) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (997, 1, 'double', 80, 2);
    -- Expected: Error - Double room price must be greater than highest single

    -- Test 4: Valid INSERT - Single room (no constraint applies)
    SELECT '=== Test 4: Valid single room (price = 90) ===' AS Test;
    INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
    VALUES (996, 1, 'single', 90, 1);
    SELECT * FROM Room WHERE roomNo = 996 AND hotelNo = 1;

    -- Cleanup
    DELETE FROM Room WHERE roomNo IN (999, 996) AND hotelNo = 1;
    \end{lstlisting}

    \textbf{Expected Results:}
    \begin{center}
    \footnotesize
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Test} & \textbf{Action} & \textbf{Result} \\
    \hline
    Test 1 & INSERT double room price 200 & Success (200 $>$ 80) \\
    Test 2 & INSERT double room price 70 & Error - price $\leq$ max single \\
    Test 3 & INSERT double room price 80 & Error - price $\leq$ max single \\
    Test 4 & INSERT single room price 90 & Success \\
    \hline
    \end{tabular}
    \end{center}

    % --------------------
    \subsection{Constraint (c) - No Overlapping Bookings}
    % --------------------

    \textbf{Requirement:} A guest cannot make two bookings with overlapping dates.

    \textbf{Solution:} Using Triggers

    \begin{lstlisting}
    DROP TRIGGER IF EXISTS trg_no_overlapping_bookings_insert;
    DELIMITER //
    CREATE TRIGGER trg_no_overlapping_bookings_insert
    BEFORE INSERT ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE overlap_count INT;
        
        SELECT COUNT(*) INTO overlap_count
        FROM Booking
        WHERE guestNo = NEW.guestNo
        AND NOT (NEW.dateTo <= dateFrom OR NEW.dateFrom >= dateTo);
        
        IF overlap_count > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Error: Guest cannot have overlapping bookings.';
        END IF;
    END //
    DELIMITER ;

    DROP TRIGGER IF EXISTS trg_no_overlapping_bookings_update;
    DELIMITER //
    CREATE TRIGGER trg_no_overlapping_bookings_update
    BEFORE UPDATE ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE overlap_count INT;
        
        SELECT COUNT(*) INTO overlap_count
        FROM Booking
        WHERE guestNo = NEW.guestNo
        AND NOT (hotelNo = OLD.hotelNo AND dateFrom = OLD.dateFrom AND roomNo = OLD.roomNo)
        AND NOT (NEW.dateTo <= dateFrom OR NEW.dateFrom >= dateTo);
        
        IF overlap_count > 0 THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Error: Guest cannot have overlapping bookings.';
        END IF;
    END //
    DELIMITER ;
    \end{lstlisting}

    \textbf{Explanation:} This trigger checks if a guest already has any booking where the dates overlap. The overlap condition is checked using: NOT (new\_end $\leq$ existing\_start OR new\_start $\geq$ existing\_end).

    \subsubsection*{Test Validation}
    \begin{lstlisting}
    -- Display current state
    SELECT '=== Current Booking Data for Guest 101 ===' AS Info;
    SELECT * FROM Booking WHERE guestNo = 101;

    -- Setup: Create initial booking for guest 101
    SELECT '=== Setup: Creating initial booking ===' AS Info;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-01-10', 1, 101, '2025-01-15', 2);
    SELECT * FROM Booking WHERE guestNo = 101;

    -- Test 1: Valid INSERT - Non-overlapping booking (after existing booking)
    SELECT '=== Test 1: Valid non-overlapping booking (Jan 20-25) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-01-20', 2, 101, '2025-01-25', 1);
    SELECT * FROM Booking WHERE guestNo = 101 ORDER BY dateFrom;

    -- Test 2: Invalid INSERT - Overlapping booking (partial overlap)
    SELECT '=== Test 2: Invalid overlapping booking (Jan 12-18) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-01-12', 3, 101, '2025-01-18', 2);
    -- Expected: Error - Guest cannot have overlapping bookings

    -- Test 3: Invalid INSERT - Complete overlap (within existing booking)
    SELECT '=== Test 3: Invalid overlapping booking (Jan 11-13) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (2, '2025-01-11', 1, 101, '2025-01-13', 1);
    -- Expected: Error - Guest cannot have overlapping bookings

    -- Test 4: Valid INSERT - Booking starts when previous ends
    SELECT '=== Test 4: Valid back-to-back booking (Jan 15-18) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-01-15', 3, 101, '2025-01-18', 2);
    SELECT * FROM Booking WHERE guestNo = 101 ORDER BY dateFrom;

    -- Cleanup
    DELETE FROM Booking WHERE guestNo = 101 AND dateFrom IN ('2025-01-10', '2025-01-15', '2025-01-20');
    \end{lstlisting}

    \textbf{Expected Results:}
    \begin{center}
    \footnotesize
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Test} & \textbf{Action} & \textbf{Result} \\
    \hline
    Setup & INSERT Jan 10-15 & Success \\
    Test 1 & INSERT Jan 20-25 (no overlap) & Success \\
    Test 2 & INSERT Jan 12-18 (partial overlap) & Error - overlap detected \\
    Test 3 & INSERT Jan 11-13 (complete overlap) & Error - overlap detected \\
    Test 4 & INSERT Jan 15-18 (back-to-back) & Success \\
    \hline
    \end{tabular}
    \end{center}

    % --------------------
    \subsection{Constraint (d) - Adult Capacity Validation}
    % --------------------

    \textbf{Requirement:} A guest cannot make a booking with number of adults greater than NumAdultMax value of booked room.

    \textbf{Solution:} Using Triggers

    \begin{lstlisting}
    DROP TRIGGER IF EXISTS trg_check_num_adults_insert;
    DELIMITER //
    CREATE TRIGGER trg_check_num_adults_insert
    BEFORE INSERT ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE max_adults INT;
        
        SELECT NumAdultMax INTO max_adults 
        FROM Room 
        WHERE roomNo = NEW.roomNo AND hotelNo = NEW.hotelNo;
        
        IF NEW.NumOfAdult > max_adults THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Error: Number of adults exceeds room capacity.';
        END IF;
    END //
    DELIMITER ;

    DROP TRIGGER IF EXISTS trg_check_num_adults_update;
    DELIMITER //
    CREATE TRIGGER trg_check_num_adults_update
    BEFORE UPDATE ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE max_adults INT;
        
        SELECT NumAdultMax INTO max_adults 
        FROM Room 
        WHERE roomNo = NEW.roomNo AND hotelNo = NEW.hotelNo;
        
        IF NEW.NumOfAdult > max_adults THEN
            SIGNAL SQLSTATE '45000'
            SET MESSAGE_TEXT = 'Error: Number of adults exceeds room capacity.';
        END IF;
    END //
    DELIMITER ;
    \end{lstlisting}

    \textbf{Explanation:} This trigger retrieves the maximum adult capacity of the room and validates that the booking does not exceed this limit.

    \subsubsection*{Test Validation}
    \begin{lstlisting}
    -- Display current state
    SELECT '=== Current Room Data ===' AS Info;
    SELECT roomNo, hotelNo, type, NumAdultMax FROM Room WHERE hotelNo = 1;

    -- Test 1: Valid INSERT - NumOfAdult <= NumAdultMax
    SELECT '=== Test 1: Valid booking (2 adults, room max = 2) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-02-01', 2, 101, '2025-02-05', 2);
    SELECT * FROM Booking WHERE hotelNo = 1 AND dateFrom = '2025-02-01';

    -- Test 2: Invalid INSERT - NumOfAdult > NumAdultMax
    SELECT '=== Test 2: Invalid booking (4 adults, room max = 2) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-02-10', 2, 101, '2025-02-15', 4);
    -- Expected: Error - Number of adults exceeds room capacity

    -- Test 3: Valid INSERT - NumOfAdult = NumAdultMax
    SELECT '=== Test 3: Valid booking (2 adults, room max = 2) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-02-10', 3, 102, '2025-02-15', 2);
    SELECT * FROM Booking WHERE hotelNo = 1 AND dateFrom = '2025-02-10' AND roomNo = 3;

    -- Test 4: Invalid INSERT - NumOfAdult exceeds by 1
    SELECT '=== Test 4: Invalid booking (3 adults, room max = 2) ===' AS Test;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-02-20', 2, 103, '2025-02-25', 3);
    -- Expected: Error - Number of adults exceeds room capacity

    -- Cleanup
    DELETE FROM Booking WHERE hotelNo = 1 AND dateFrom IN ('2025-02-01', '2025-02-10');
    \end{lstlisting}

    \textbf{Expected Results:}
    \begin{center}
    \footnotesize
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Test} & \textbf{Action} & \textbf{Result} \\
    \hline
    Test 1 & INSERT 2 adults (room max 2) & Success \\
    Test 2 & INSERT 4 adults (room max 2) & Error - exceeds capacity \\
    Test 3 & INSERT 2 adults (room max 2) & Success \\
    Test 4 & INSERT 3 adults (room max 2) & Error - exceeds capacity \\
    \hline
    \end{tabular}
    \end{center}

    % --------------------
    \subsection{Constraint (e) - Automatic TotalAmount Calculation}
    % --------------------

    \textbf{Requirement:} Automatically calculate the value for totalAmount column of Guest relation.

    \textbf{Solution:} Using Triggers (Derived Attribute)

    \begin{lstlisting}
    -- Trigger for INSERT: Add booking cost to guest's total
    DROP TRIGGER IF EXISTS trg_update_total_amount_insert;
    DELIMITER //
    CREATE TRIGGER trg_update_total_amount_insert
    AFTER INSERT ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE room_price DECIMAL(10, 2);
        DECLARE num_days INT;
        DECLARE booking_cost DECIMAL(12, 2);
        
        SELECT price INTO room_price FROM Room 
        WHERE roomNo = NEW.roomNo AND hotelNo = NEW.hotelNo;
        
        SET num_days = DATEDIFF(NEW.dateTo, NEW.dateFrom);
        SET booking_cost = room_price * num_days;
        
        UPDATE Guest 
        SET TotalAmount = TotalAmount + booking_cost 
        WHERE guestNo = NEW.guestNo;
    END //
    DELIMITER ;

    -- Trigger for DELETE: Subtract booking cost from guest's total
    DROP TRIGGER IF EXISTS trg_update_total_amount_delete;
    DELIMITER //
    CREATE TRIGGER trg_update_total_amount_delete
    AFTER DELETE ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE room_price DECIMAL(10, 2);
        DECLARE num_days INT;
        DECLARE booking_cost DECIMAL(12, 2);
        
        SELECT price INTO room_price FROM Room 
        WHERE roomNo = OLD.roomNo AND hotelNo = OLD.hotelNo;
        
        SET num_days = DATEDIFF(OLD.dateTo, OLD.dateFrom);
        SET booking_cost = room_price * num_days;
        
        UPDATE Guest 
        SET TotalAmount = TotalAmount - booking_cost 
        WHERE guestNo = OLD.guestNo;
    END //
    DELIMITER ;

    -- Trigger for UPDATE: Adjust both guests' totals
    DROP TRIGGER IF EXISTS trg_update_total_amount_update;
    DELIMITER //
    CREATE TRIGGER trg_update_total_amount_update
    AFTER UPDATE ON Booking
    FOR EACH ROW
    BEGIN
        DECLARE old_room_price DECIMAL(10, 2);
        DECLARE new_room_price DECIMAL(10, 2);
        DECLARE old_num_days INT;
        DECLARE new_num_days INT;
        DECLARE old_booking_cost DECIMAL(12, 2);
        DECLARE new_booking_cost DECIMAL(12, 2);
        
        SELECT price INTO old_room_price FROM Room 
        WHERE roomNo = OLD.roomNo AND hotelNo = OLD.hotelNo;
        SELECT price INTO new_room_price FROM Room 
        WHERE roomNo = NEW.roomNo AND hotelNo = NEW.hotelNo;
        
        SET old_num_days = DATEDIFF(OLD.dateTo, OLD.dateFrom);
        SET new_num_days = DATEDIFF(NEW.dateTo, NEW.dateFrom);
        SET old_booking_cost = old_room_price * old_num_days;
        SET new_booking_cost = new_room_price * new_num_days;
        
        UPDATE Guest SET TotalAmount = TotalAmount - old_booking_cost 
        WHERE guestNo = OLD.guestNo;
        
        UPDATE Guest SET TotalAmount = TotalAmount + new_booking_cost 
        WHERE guestNo = NEW.guestNo;
    END //
    DELIMITER ;
    \end{lstlisting}

    \textbf{Explanation:} Three triggers maintain the TotalAmount: INSERT adds cost (room price $\times$ days), DELETE subtracts cost, and UPDATE adjusts both guests' totals when booking details change.

    \subsubsection*{Test Validation}
    \begin{lstlisting}
    -- Display initial state
    SELECT '=== Initial Guest TotalAmount ===' AS Info;
    SELECT guestNo, guestName, TotalAmount FROM Guest;

    -- Display Room prices
    SELECT '=== Room Prices ===' AS Info;
    SELECT roomNo, hotelNo, price FROM Room WHERE hotelNo = 1;

    -- Test 1: INSERT booking - TotalAmount should increase automatically
    SELECT '=== Test 1: INSERT booking (5 days * 80 = 400) ===' AS Test;
    SELECT 'Before INSERT:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-03-01', 1, 101, '2025-03-06', 2);  -- 5 days * 80 = 400
    SELECT 'After INSERT:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;

    -- Test 2: INSERT another booking - TotalAmount should increase more
    SELECT '=== Test 2: INSERT second booking (3 days * 150 = 450) ===' AS Test;
    SELECT 'Before INSERT:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    INSERT INTO Booking (hotelNo, dateFrom, roomNo, guestNo, dateTo, NumOfAdult)
    VALUES (1, '2025-03-10', 2, 101, '2025-03-13', 1);  -- 3 days * 150 = 450
    SELECT 'After INSERT:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    -- Expected: TotalAmount = 400 + 450 = 850

    -- Test 3: DELETE booking - TotalAmount should decrease
    SELECT '=== Test 3: DELETE first booking (subtract 400) ===' AS Test;
    SELECT 'Before DELETE:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    DELETE FROM Booking WHERE hotelNo = 1 AND dateFrom = '2025-03-01' AND roomNo = 1;
    SELECT 'After DELETE:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    -- Expected: TotalAmount = 850 - 400 = 450

    -- Test 4: UPDATE booking - Change dates (TotalAmount should adjust)
    SELECT '=== Test 4: UPDATE booking dates (3 days to 7 days) ===' AS Test;
    SELECT 'Before UPDATE:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    UPDATE Booking 
    SET dateTo = '2025-03-17'  -- Change from 3 days to 7 days (7 * 150 = 1050)
    WHERE hotelNo = 1 AND dateFrom = '2025-03-10' AND roomNo = 2;
    SELECT 'After UPDATE:' AS Status, TotalAmount FROM Guest WHERE guestNo = 101;
    -- Expected: TotalAmount = 450 - 450 + 1050 = 1050

    -- Cleanup
    DELETE FROM Booking WHERE hotelNo = 1 AND dateFrom = '2025-03-10';
    UPDATE Guest SET TotalAmount = 0 WHERE guestNo IN (101, 102);
    \end{lstlisting}

    \textbf{Expected Results:}
    \begin{center}
    \footnotesize
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Test} & \textbf{Action} & \textbf{Result} \\
    \hline
    Test 1 & INSERT 5-day booking & TotalAmount +400 \\
    Test 2 & INSERT 3-day booking & TotalAmount +450 (total 850) \\
    Test 3 & DELETE first booking & TotalAmount -400 (total 450) \\
    Test 4 & UPDATE dates (3 to 7 days) & TotalAmount 450$\rightarrow$1050 \\
    \hline
    \end{tabular}
    \end{center}

    % --------------------
    \subsection{Constraint (f) - INSTEAD OF Trigger for View}
    % --------------------

    \textbf{Requirement:} Create an INSTEAD OF database trigger that will allow data to be inserted into the LondonHotelRoom view.

    \textbf{View Definition:}
    \begin{lstlisting}
    CREATE VIEW LondonHotelRoom AS
    SELECT h.hotelNo, hotelName, city, roomNo, type, price
    FROM Hotel h, Room r
    WHERE h.hotelNo = r.hotelNo AND city = 'London';
    \end{lstlisting}

    \textbf{MySQL Solution:} Stored Procedure (MySQL does not support INSTEAD OF triggers)

    \begin{lstlisting}
    DROP PROCEDURE IF EXISTS InsertIntoLondonHotelRoom;
    DELIMITER //
    CREATE PROCEDURE InsertIntoLondonHotelRoom(
        IN p_hotelNo INT,
        IN p_hotelName VARCHAR(50),
        IN p_roomNo INT,
        IN p_type VARCHAR(20),
        IN p_price DECIMAL(10, 2),
        IN p_numAdultMax INT
    )
    BEGIN
        DECLARE hotel_exists INT;
        
        SELECT COUNT(*) INTO hotel_exists FROM Hotel WHERE hotelNo = p_hotelNo;
        
        IF hotel_exists = 0 THEN
            INSERT INTO Hotel (hotelNo, hotelName, city) 
            VALUES (p_hotelNo, p_hotelName, 'London');
        ELSE
            UPDATE Hotel SET hotelName = p_hotelName WHERE hotelNo = p_hotelNo;
        END IF;
        
        INSERT INTO Room (roomNo, hotelNo, type, price, NumAdultMax) 
        VALUES (p_roomNo, p_hotelNo, p_type, p_price, p_numAdultMax);
    END //
    DELIMITER ;

    -- Usage:
    -- CALL InsertIntoLondonHotelRoom(99, 'New London Hotel', 901, 'single', 110, 1);
    \end{lstlisting}

    \textbf{Explanation:} MySQL does not support INSTEAD OF triggers on views. Instead, we use a stored procedure that inserts into both the Hotel and Room tables, ensuring the city is always 'London'.

    \subsubsection*{Test Validation}
    \begin{lstlisting}
    -- Display current state
    SELECT '=== Current Hotels and Rooms ===' AS Info;
    SELECT h.hotelNo, h.hotelName, h.city, r.roomNo, r.type, r.price
    FROM Hotel h
    LEFT JOIN Room r ON h.hotelNo = r.hotelNo
    WHERE h.city = 'London';

    -- Test 1: Insert into view using stored procedure - New hotel and room
    SELECT '=== Test 1: Insert new hotel (99) and room (901) ===' AS Test;
    CALL InsertIntoLondonHotelRoom(99, 'New London Hotel', 901, 'single', 110, 1);
    SELECT * FROM Hotel WHERE hotelNo = 99;
    SELECT * FROM Room WHERE hotelNo = 99 AND roomNo = 901;

    -- Test 2: Insert into view - Existing hotel, new room
    SELECT '=== Test 2: Insert room (902) to existing hotel (99) ===' AS Test;
    CALL InsertIntoLondonHotelRoom(99, 'Updated London Hotel', 902, 'double', 180, 2);
    SELECT * FROM Hotel WHERE hotelNo = 99;
    SELECT * FROM Room WHERE hotelNo = 99 ORDER BY roomNo;

    -- Test 3: Verify the view shows inserted data
    SELECT '=== Test 3: Query LondonHotelRoom view ===' AS Test;
    SELECT * FROM LondonHotelRoom WHERE hotelNo = 99;

    -- Test 4: Insert another room to the same hotel
    SELECT '=== Test 4: Insert third room (903) ===' AS Test;
    CALL InsertIntoLondonHotelRoom(99, 'New London Hotel', 903, 'suite', 250, 4);
    SELECT * FROM LondonHotelRoom WHERE hotelNo = 99 ORDER BY roomNo;

    -- Cleanup
    DELETE FROM Room WHERE hotelNo = 99;
    DELETE FROM Hotel WHERE hotelNo = 99;
    \end{lstlisting}

    \textbf{Expected Results:}
    \begin{center}
    \footnotesize
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Test} & \textbf{Action} & \textbf{Result} \\
    \hline
    Test 1 & Insert new hotel 99 + room 901 & Success \\
    Test 2 & Insert room 902 to hotel 99 & Success \\
    Test 3 & Query view for hotel 99 & Shows 2 rooms \\
    Test 4 & Insert room 903 & Success (3 rooms total) \\
    \hline
    \end{tabular}
    \end{center}

    \textbf{Standard SQL (SQL Server/PostgreSQL/Oracle):}

    \textbf{SQL Server:}
    \begin{lstlisting}
    CREATE TRIGGER trg_instead_of_insert_LondonHotelRoom
    ON LondonHotelRoom
    INSTEAD OF INSERT
    AS
    BEGIN
        -- Insert/update Hotel table
        MERGE Hotel AS target
        USING inserted AS source
        ON target.hotelNo = source.hotelNo
        WHEN MATCHED THEN
            UPDATE SET hotelName = source.hotelName
        WHEN NOT MATCHED THEN
            INSERT (hotelNo, hotelName, city)
            VALUES (source.hotelNo, source.hotelName, 'London');
        
        -- Insert into Room table
        INSERT INTO Room (roomNo, hotelNo, type, price)
        SELECT roomNo, hotelNo, type, price FROM inserted;
    END;
    \end{lstlisting}

    \textbf{PostgreSQL:}
    \begin{lstlisting}
    CREATE OR REPLACE FUNCTION fn_instead_of_insert_LondonHotelRoom()
    RETURNS TRIGGER AS $$
    BEGIN
        IF NOT EXISTS (SELECT 1 FROM Hotel WHERE hotelNo = NEW.hotelNo) THEN
            INSERT INTO Hotel (hotelNo, hotelName, city)
            VALUES (NEW.hotelNo, NEW.hotelName, 'London');
        ELSE
            UPDATE Hotel SET hotelName = NEW.hotelName WHERE hotelNo = NEW.hotelNo;
        END IF;
        
        INSERT INTO Room (roomNo, hotelNo, type, price)
        VALUES (NEW.roomNo, NEW.hotelNo, NEW.type, NEW.price);
        
        RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER trg_instead_of_insert_LondonHotelRoom
    INSTEAD OF INSERT ON LondonHotelRoom
    FOR EACH ROW
    EXECUTE FUNCTION fn_instead_of_insert_LondonHotelRoom();
    \end{lstlisting}

    \textbf{Note:} INSTEAD OF triggers intercept INSERT/UPDATE/DELETE operations on views and execute custom logic instead. For databases that support them (SQL Server, PostgreSQL, Oracle), the trigger directly handles inserts into the view by inserting into both the Hotel and Room tables.

